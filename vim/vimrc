" Need to call on initially to support git
filetype on
filetype off
set nocompatible

" Vundle initialization
set rtp+=~/.vim/bundle/vundle.vim
call vundle#begin()
" alternatively, pass a path where Vundle should install plugins
"call vundle#begin('~/some/path/here')

" let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'

Plugin 'tpope/vim-surround'
Plugin 'tpope/vim-repeat'
Plugin 'tpope/vim-bundler'
Plugin 'tpope/vim-rails'
Plugin 'tpope/vim-fugitive'
Plugin 'tpope/vim-endwise'
Plugin 'tpope/vim-commentary'
Plugin 'tpope/vim-speeddating'
Plugin 'tpope/vim-fireplace'
Plugin 'vim-ruby/vim-ruby'
Plugin 'kana/vim-textobj-user'
Plugin 'nelstrom/vim-textobj-rubyblock'
Plugin 'mudge/runspec.vim'
Plugin 'ervandew/supertab'
Plugin 'vim-scripts/YankRing.vim'
Plugin 'benmills/vimux.git'
Plugin 'editorconfig/editorconfig-vim'
Plugin 'mattn/webapi-vim'
Plugin 'mattn/gist-vim'
Plugin 'mbbill/undotree'
Plugin 'flazz/vim-colorschemes'
" git: git://github.com/garbas/vim-snipmate.git
" vim-addon-mw-utils: #needed for snipmate
" git: git://github.com/MarcWeber/vim-addon-mw-utils.git
" tlib: #needed for snipmate
" git: git://github.com/tomtom/tlib_vim.git
" git: git://github.com/nelstrom/gundo.vim.git
" git: https://github.com/lukaszkorecki/CoffeeTags.git

Plugin 'wincent/terminus'
" Plugin 'git://git.wincent.com/command-t.git'
Plugin 'elixir-lang/vim-elixir'

Plugin 'kylef/apiblueprint.vim'
Plugin 'kien/ctrlp.vim'
Plugin 'majutsushi/tagbar'
Plugin 'kchmck/vim-coffee-script'

Plugin 'junegunn/vim-easy-align'
Plugin 'corntrace/bufexplorer'
Plugin 'Raimondi/delimitMate'
" Plugin 'powerline/powerline'
Plugin 'bling/vim-airline'
" Plugin 'itchyny/lightline.vim'
Plugin 'airblade/vim-rooter'
Plugin 'scrooloose/syntastic'
Plugin 'yaifa.vim'
" Plugin 'matchit.zip'
Plugin 'exvim/ex-matchit'
Plugin 'amirh/HTML-AutoCloseTag'
Plugin 'altercation/vim-colors-solarized'
Plugin 'rking/ag.vim'
Plugin 'Shougo/neocomplcache.vim'
Plugin 'techlivezheng/vim-plugin-minibufexpl'
Plugin 'taglist.vim'

" Syntax plugins
Plugin 'elzr/vim-json'
Plugin 'plasticboy/vim-markdown'
Plugin 'tpope/vim-haml'
Plugin 'slim-template/vim-slim.git'
Plugin 'docker/docker' , {'rtp': '/contrib/syntax/vim/'}
Plugin 'yaml/yaml.vim'

Plugin 'hail2u/vim-css3-syntax'
Plugin 'othree/html5-syntax.vim'
Plugin 'jelera/vim-javascript-syntax'
Plugin 'othree/javascript-libraries-syntax.vim'
Plugin 'jiangmiao/simple-javascript-indenter'
Plugin 'puppetlabs/puppet-syntax-vim'
Plugin 'jQuery'
Plugin 'groenewege/vim-less'
Plugin 'fatih/vim-go'

call vundle#end()
filetype plugin indent on

" Enable syntax
syntax enable
" syntax on


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Files, backups and undo
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Turn backup off, since most stuff is in SVN, git et.c anyway...
set nobackup
set nowb
set noswapfile

""""""""""""""""""""""""""""""
" => Visual mode related
""""""""""""""""""""""""""""""
" Visual mode pressing * or # searches for the current selection
" Super useful! From an idea by Michael Naumann
vnoremap <silent> * :call VisualSelection('f')<CR>
vnoremap <silent> # :call VisualSelection('b')<CR>

" When you press <leader>r you can search and replace the selected text
vnoremap <silent> <leader>r :call VisualSelection('replace')<CR>
" map . in visual mode
vnoremap . :norm.<cr>

" unmap F1 help
nmap <F1> <nop>
imap <F1> <nop>

" unmap ex mode: 'Type visual to go into Normal mode.'
nnoremap Q <nop>

map - ddp
map _ ddkP
" vmap - dp
" vmap - dkP

" Ensure vim uses bash
set shell=/bin/bash

" Some kind of security thing
set modelines=0

" Set the default font
set guifont=Meslo\ LG\ S\ for\ Powerline:h12
let g:airline_powerline_fonts = 1
" set guifont=Monaco:h12

" Automatically reload on file changes
set autoread
set autowrite

" Automatically attempt to handle indentation
set autoindent
set si

" Set our mapleader key
let mapleader = ','
let g:mapleader = ","
noremap \ ,

" stolen from https://bitbucket.org/sjl/dotfiles/src/tip/vim/vimrc
" Keep search matches in the middle of the window.
nnoremap n nzzzv
nnoremap N Nzzzv

" Automatically attempt to set the working directory to the current
" file. This value will be superceeded by rooter if it is installed
set autochdir

" Display the current mode at the bottom of the window
set showmode

" Extra information about the command you're running in the status bar
set showcmd
" This makes vim act like all other editors, buffers can
" exist in the background without being in a window.
" http://items.sjbach.com/319/configuring-vim-right
set hidden
" set ttimeoutlen=50        " Make Esc work faster"
set timeout timeoutlen=500 ttimeoutlen=100

" Auto complete filenames when in :Ex mode, etc
set wildmenu
" set wildmenu=full
set wildmode=list:longest

set visualbell
set cursorline " highlight current line
set ttyfast

" For regular expressions turn magic on
set magic

" Height of the command bar
set cmdheight=2

let g:html_use_css = "1"
let xml_use_xhtml = 1

set background=dark
set history=7000
set hlsearch
" ignore case - ignorowanie wielkosci znakow przy
" przeszukiwaniu tekstu
set ic
set scs
" Smart case searching. Case insensitive if all lowercase, but if you
" provide uppercase it will force matching case
set ignorecase smartcase
set incsearch

autocmd FileType markdown setlocal shiftwidth=4 softtabstop=4 tabstop=4 wrap linebreak nolist wrap lbr colorcolumn=0 synmaxcol=999999

" Visually display matching braces
set showmatch " show bracket matches
" How many tenths of a second to blink when matching brackets
set mat=2

set ruler

" set backspace=2
set backspace=indent,eol,start

" Always show the status line
set laststatus=2
set scrolloff=3

set cindent

" Line number rules
set number
set relativenumber " show relative line numbers

" Tab rules
set expandtab
set smarttab " Be smart when using tabs ;)

set tabstop=2
set shiftwidth=2
set softtabstop=2

set cm=blowfish
set textwidth=90
set formatoptions=qrn1

set colorcolumn=90
highlight ColorColumn ctermbg=lightgrey guibg=lightgrey

set foldmethod=expr
set foldlevelstart=2
colo railscasts

" Set the default encoding to the always trusty UTF-8
set encoding=utf-8

" Switching between buffers using Ctrl+Tab
nnoremap <c-Tab> :bnext<CR>
nnoremap <c-S-Tab> :bprevious<CR>
" Switching between tabs using Shift+Tab
nnoremap <Tab> :tabn<CR>
nnoremap <S-Tab> :tabp<CR>
map Y y$

" Searching using Ctrl+P
map <leader>o :CtrlPMixed<CR>
nnoremap <leader>. :CtrlPTag<cr>
nnoremap <silent> <leader>b :TagbarToggle<CR>
map <leader>e :MBEOpen<cr>
map <leader>c :MBEClose<cr>
map <leader>t :MBEToggle<cr>
map <leader>f :MBEFocus<cr>
noremap <C-TAB>   :MBEbf<CR>
noremap <C-S-TAB> :MBEbb<CR>
" nnoremap <leader>ev :vsplit $MYVIMRC<CR>
" nnoremap <leader>sv :source $MYVIMRC<cr>

" Disable highlight when <leader>, is pressed
map <silent> <leader>, :noh<cr>
" Close all the buffers
map <leader>ba :1,1000 bd!<cr>

" automatically rebalance windows on vim resize
autocmd VimResized * :wincmd =

" wrap quickfix window
autocmd FileType qf setlocal wrap linebreak

set splitbelow
set splitright

" Stop Vim dying if there's massively long lines.
" set synmaxcol=250

" Don't add the comment prefix when I hit enter or o/O on a comment line.
" autocmd FileType * setlocal formatoptions-=r formatoptions-=o

" new file in current directory
" map <Leader>nf :e <C-R>=expand("%:p:h") . "/" <CR>

" Prevent Vim from clobbering the scrollback buffer. See
" http://www.shallowsky.com/linux/noaltscreen.html
" set t_ti= t_te=

" FZF.vim
" nnoremap <leader>t :Files<cr>
" nnoremap <leader>b :Buffers<cr>

" nmap <leader><tab> <plug>(fzf-maps-n)
" xmap <leader><tab> <plug>(fzf-maps-x)
" omap <leader><tab> <plug>(fzf-maps-o)

" Insert mode completion
" imap <c-x><c-f> <plug>(fzf-complete-path)
" imap <c-x><c-j> <plug>(fzf-complete-file-ag)
" imap <c-x><c-l> <plug>(fzf-complete-line)

" makes fzf never use tmux
" https://github.com/junegunn/fzf.vim/issues/66#issuecomment-169362556
" let g:fzf_layout = {}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Editing mappings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Remap VIM 0 to first non-blank character
map 0 ^

" Return to last edit position when opening files (You want this!)
autocmd BufReadPost *
     \ if line("'\"") > 0 && line("'\"") <= line("$") |
     \   exe "normal! g`\"" |
     \ endif
" Remember info about open buffers on close
set viminfo^=%

" Format the status line
set statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{getcwd()}%h\ \ \ Line:\ %l


" Do syntax check when the buffer is first loaded
let g:syntastic_check_on_open=0
let g:syntastic_disabled_filetypes=['m.html']
let g:syntastic_html_checkers=['']
" let g:syntastic_html_tidy_ignore_errors = [
"     \  'plain text isn''t allowed in <head> elements',
"     \  '<base> escaping malformed URI reference',
"     \  'discarding unexpected <body>',
"     \  '<script> escaping malformed URI reference',
"     \  'content occurs after end of body',
"     \  '</head> isn''t allowed in <body> elements'
"     \ ]

" Don't overindent javascript
let g:SimpleJsIndenter_BriefMode=1

" Hide .DS_Store and .git directories from Vim
let g:netrw_list_hide='.DS_Store,^\.git/$'

" Start neocompletecache automatically
let g:neocomplcache_enable_at_startup = 1

" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)

" rabl files
au BufRead,BufNewFile *.rabl setf ruby
" let ruby_fold = 1
set foldlevelstart=1
autocmd Syntax c,cpp,vim,ruby setlocal foldmethod=syntax
" autocmd Syntax c,cpp,vim,rb normal zR

" Every time the user issues a :w command, Vim will automatically remove all trailing whitespace before saving.
autocmd BufWritePre * :%s/\s\+$//e

" Do :help cope if you are unsure what cope is. It's super useful!
"
" When you search with vimgrep, display your results in cope by doing:
"   <leader>cc
"
" To go to the next search result do:
"   <leader>n
"
" To go to the previous search results do:
"   <leader>p
"
" map <leader>cc :botright cope<cr>
" map <leader>co ggVGy:tabnew<cr>:set syntax=qf<cr>pgg
" map <leader>n :cn<cr>
" map <leader>p :cp<cr>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" The Silver Searcher
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

if executable('ag')
  " Searching using Ag
  map <leader>a :Ag!<space>
  " Use ag over grep
  set grepprg=ag\ --nogroup\ --nocolor
  set wildignore=*.so,*.swp,*.aux,*.zip
  set wildignore+=*.o,*.obj,*~ "stuff to ignore when tab completing
  set wildignore+=*vim/backups*
  set wildignore+=*sass-cache*
  set wildignore+=*DS_Store*
  set wildignore+=vendor/rails/**
  set wildignore+=vendor/cache/**
  set wildignore+=*.git
  set wildignore+=*.gem
  set wildignore+=node_modules,_site
  set wildignore+=log/**
  set wildignore+=tmp/**
  set wildignore+=*.png,*.jpg,*.gif

  " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
  let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'

  " ag is fast enough that CtrlP doesn't need to cache
  let g:ctrlp_use_caching = 0
  let g:ctrlp_max_height = 30
  let g:ctrlp_working_path_mode = 0
  let g:ctrlp_match_window_reversed = 0
  let g:ag_working_path_mode = "r"
  " search for word under the cursor
  nnoremap K :Ag! "\b<C-R><C-W>\b"<CR>
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Coffeescript
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
autocmd BufNewFile,BufReadPost *.coffee setl foldmethod=indent nofoldenable
autocmd BufRead,BufNewFile *.es6 setfiletype javascript
autocmd BufRead,BufNewFile *.ts setfiletype javascript
"autocmd BufNewFile,BufReadPost *.coffee setl shiftwidth=2 expandtab
let coffee = '/usr/local/bin/coffee'
" special highlighting for React and Lodash
let g:used_javascript_libs = 'react,lodash'

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Helper functions
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! CmdLine(str)
    exe "menu Foo.Bar :" . a:str
    emenu Foo.Bar
    unmenu Foo
endfunction

function! VisualSelection(direction) range
    let l:saved_reg = @"
    execute "normal! vgvy"

    let l:pattern = escape(@", '\\/.*$^~[]')
    let l:pattern = substitute(l:pattern, "\n$", "", "")

    if a:direction == 'b'
        execute "normal ?" . l:pattern . "^M"
    elseif a:direction == 'gv'
        call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
    elseif a:direction == 'replace'
        call CmdLine("%s" . '/'. l:pattern . '/')
    elseif a:direction == 'f'
        execute "normal /" . l:pattern . "^M"
    endif

    let @/ = l:pattern
    let @" = l:saved_reg
endfunction

" Returns true if paste mode is enabled
function! HasPaste()
    if &paste
        return 'PASTE MODE  '
    en
    return ''
endfunction


" rename current file, via Gary Bernhardt
function! RenameFile()
  let old_name = expand('%')
  let new_name = input('New file name: ', expand('%'))
  if new_name != '' && new_name != old_name
    exec ':saveas ' . new_name
    exec ':silent !rm ' . old_name
    redraw!
  endif
endfunction
map <leader>n :call RenameFile()<cr>

